      - name: Generate NEW sandbox payload with DELTAS (lean + aligned + skip-if-same)
        env:
          LIVE_URL:  ${{ env.LIVE_URL }}
          BUILD_DIR: ${{ env.BUILD_DIR }}
        run: |
          python - <<'PY'
          import os, json, sys, urllib.request, time
          from urllib.error import URLError, HTTPError
          from datetime import datetime, timezone, timedelta

          # ---------- TZ helpers ----------
          try:
              from zoneinfo import ZoneInfo
              AZ = ZoneInfo("America/Phoenix")
          except Exception:
              AZ = timezone(timedelta(hours=-7))  # fallback

          def now_az(): return datetime.now(tz=AZ)
          def az_iso(dt=None): return (dt or now_az()).replace(microsecond=0).isoformat()
          def floor_to_interval(dt, minutes):
              if dt.tzinfo is None: dt = dt.replace(tzinfo=AZ)
              m = (dt.minute // minutes) * minutes
              return dt.replace(minute=m, second=0, microsecond=0)

          # ---------- IO ----------
          LIVE_URL  = os.environ["LIVE_URL"]
          BUILD_DIR = os.environ["BUILD_DIR"]
          OUT = os.path.join(BUILD_DIR, "outlook_intraday.json")
          HB  = os.path.join(BUILD_DIR, "heartbeat_10min.txt")
          PREV = os.path.join(BUILD_DIR, "prev.json")

          def fetch_json(url: str):
              try:
                  u = url + ("&t=" if "?" in url else "?t=") + str(int(time.time()))
                  req = urllib.request.Request(u, headers={"Cache-Control":"no-store","User-Agent":"sandbox-deltas/1.1"})
                  with urllib.request.urlopen(req, timeout=20) as resp:
                      if resp.status != 200: return None
                      return json.loads(resp.read().decode("utf-8"))
              except (URLError, HTTPError, TimeoutError, json.JSONDecodeError):
                  return None

          def load_json(path: str):
              try:
                  if os.path.isfile(path):
                      with open(path,"r",encoding="utf-8") as f: return json.load(f)
              except Exception:
                  pass
              return None

          # ---------- math ----------
          def pct(num, den): return 0.0 if den == 0 else 100.0 * num / den
          def clip2(x, eps=0.05): return 0.0 if abs(x) < eps else round(x, 2)

          CANON = [
              "information technology","materials","health care","communication services",
              "real estate","energy","consumer staples","consumer discretionary",
              "financials","utilities","industrials",
          ]
          ALIASES = {
              "healthcare":"health care","health-care":"health care","health care":"health care",
              "info tech":"information technology","technology":"information technology","tech":"information technology",
              "communications":"communication services","comm services":"communication services","telecom":"communication services",
              "staples":"consumer staples","discretionary":"consumer discretionary",
              "finance":"financials","industry":"industrials","reit":"real estate","reits":"real estate",
          }
          def canon_name(n:str) -> str:
              n = (n or "").strip().lower()
              return ALIASES.get(n, n)

          def sector_map(cards):
              m = {}
              for c in cards or []:
                  s = canon_name(c.get("sector",""))
                  if not s: continue
                  nh = int(c.get("nh",0)); nl = int(c.get("nl",0))
                  up = int(c.get("up",0)); dn = int(c.get("down",0))
                  m[s] = {"breadth_pct": pct(nh, nh+nl), "momentum_pct": pct(up, up+dn), "nh": nh, "nl": nl}
              return m

          def summarize(cards):
              nh=nl=up=dn=0
              for c in cards or []:
                  nh += int(c.get("nh",0)); nl += int(c.get("nl",0))
                  up += int(c.get("up",0)); dn += int(c.get("down",0))
              return pct(nh, nh+nl), pct(up, up+dn)

          # ---------- fetch current + prev ----------
          curr = fetch_json(LIVE_URL)
          if not curr:
              print("ERROR: could not fetch /live/intraday", file=sys.stderr)
              sys.exit(2)
          prev = load_json(PREV)

          source_ts = curr.get("sectorsUpdatedAt") or curr.get("updated_at")  # prefer AZ string if present
          bar_ts    = az_iso(floor_to_interval(now_az(), 5))                  # aligned 5m boundary

          prev_src = prev.get("sourceTs") if isinstance(prev, dict) else None
          prev_bar = prev.get("barTs")    if isinstance(prev, dict) else None

          # ---------- skip-if-same ----------
          if prev and source_ts and prev_src == source_ts and prev_bar == bar_ts:
              os.makedirs(BUILD_DIR, exist_ok=True)
              with open(HB,"w",encoding="utf-8") as f: f.write(az_iso()+"\n")
              # keep previous out.json so we don't churn zeros
              # also copy prev forward so later steps push it
              with open(OUT,"w",encoding="utf-8") as f: json.dump(prev, f, ensure_ascii=False, separators=(",",":"))
              print(f"[SKIP] same src={source_ts} bar={bar_ts} â†’ kept last deltas")
              sys.exit(0)

          # ---------- build deltas (canonical 11 keys) ----------
          cards_now  = curr.get("sectorCards") or []
          cards_prev = prev.get("sectorCards") if isinstance(prev, dict) else []
          now_map    = sector_map(cards_now)
          prev_map   = sector_map(cards_prev)

          d_sectors = {}
          for s in CANON:
              a = now_map.get(s,  {"breadth_pct":0.0,"momentum_pct":0.0,"nh":0,"nl":0})
              b = prev_map.get(s, {"breadth_pct":0.0,"momentum_pct":0.0,"nh":0,"nl":0})
              dB = clip2(a["breadth_pct"]  - b["breadth_pct"])
              dM = clip2(a["momentum_pct"] - b["momentum_pct"])
              d_sectors[s] = {
                  "dBreadthPct": dB,
                  "dMomentumPct": dM,
                  "netTilt":     clip2((dB + dM)/2.0),
                  "dNetNH":      (a["nh"] - a["nl"]) - (b["nh"] - b["nl"]),
              }

          cb, cm = summarize(cards_now)
          pb, pm = summarize(cards_prev) if cards_prev else (0.0, 0.0)
          d_market = {
              "dBreadthPct": clip2(cb - pb),
              "dMomentumPct": clip2(cm - pm),
              "netTilt":     clip2(((cb - pb) + (cm - pm))/2.0),
          }

          # ---------- LEAN payload ----------
          out = {
              "version": "sandbox-10m-deltas",
              "deltasUpdatedAt": az_iso(),
              "barTs": bar_ts,
              "sourceTs": source_ts,
              "metrics": {
                  "breadth_pct":  curr.get("metrics",{}).get("breadth_pct"),
                  "momentum_pct": curr.get("metrics",{}).get("momentum_pct"),
              },
              "deltas": {
                  "market": d_market,
                  "sectors": d_sectors,
              },
              # If some consumer still needs cards, uncomment:
              # "sectorCards": cards_now,
              "deltaSpec": "breadth_pct,momentum_pct;round=2;clip=0.05;canon=11",
          }

          os.makedirs(BUILD_DIR, exist_ok=True)
          with open(OUT, "w", encoding="utf-8") as f:
              json.dump(out, f, ensure_ascii=False, separators=(",", ":"))
          with open(HB, "w", encoding="utf-8") as f:
              f.write(az_iso() + "\n")

          print(f"[OK] deltas: market={d_market}  barTs={bar_ts}  sourceTs={source_ts}")
          PY
