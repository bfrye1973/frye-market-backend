// services/core/jobs/updateSmzShelves.js
// Smart Money Shelves Job — writes smz-shelves.json (blue/red shelves)
//
// ✅ LOCKED "INSTITUTION STYLE" BEHAVIOR:
// - Auto shelves generated by scanner
// - Manual shelves loaded from data/smz-manual-shelves.json (source-of-truth)
// - Manual shelves can use manualRange (wins) or priceRange
// - Final output is within ±BAND_POINTS of currentPriceAnchor
// - Manual shelves win on overlap (TYPE-AWARE: manual Acc removes auto Acc only; manual Dist removes auto Dist only)
// - Manual shelves can override score via scoreOverride
// - Strength remap keeps shelves in 60–89 band
// - FINAL: collapse overlaps into clusters (max 1 Acc + 1 Dist per cluster)
// - Cluster definition: overlap OR small gap threshold (cluster_gap_pts = 0.60)
// - Global cap: max 8 shelves total (TradingView clean feel)
//
// ✅ TEMP RULE (PER USER, FOR CLEAN LOOK RIGHT NOW):
// - If a shelf touches/overlaps ANY sticky institutional structure (structures_sticky),
//   remove the shelf (strict any overlap).
// - We check against structures_sticky only (authoritative).
//
// ✅ NEW LOCKED RULE (PER USER):
// - NO TWO SHELVES CAN TOUCH/OVERLAP in final output.
// - Higher strength shelf always wins.
// - Implemented as final "no-touch winner" pass after clustering + global cap.
//
// Uses DEEP provider (jobs only), chart provider remains untouched.
//
// Efficient lookback plan (LOCKED for shelves):
// - 15m = 180 days
// - 30m = 180 days
// - 1h  = 180 days

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

import { computeShelves } from "../logic/smzShelvesScanner.js";
import { getBarsFromPolygonDeep } from "../../../api/providers/polygonBarsDeep.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OUTFILE = path.resolve(__dirname, "../data/smz-shelves.json");
const MANUAL_FILE = path.resolve(__dirname, "../data/smz-manual-shelves.json");

// ✅ Read institutional truth from Engine 1 output
const LEVELS_FILE = path.resolve(__dirname, "../data/smz-levels.json");

// Config
const SYMBOL = "SPY";
const BAND_POINTS = 40;

// ✅ Lookback days (LOCKED for shelves)
const DAYS_15M = 180;
const DAYS_30M = 180;
const DAYS_1H = 180;

// Shelves strength band (LOCKED semantics)
const SHELF_STRENGTH_LO = 60;
const SHELF_STRENGTH_HI = 89;

// ✅ Cluster rules (LOCKED)
const SHELF_CLUSTER_OVERLAP = 0.55; // overlap ratio threshold
const SHELF_CLUSTER_GAP_PTS = 0.60; // gap threshold (pts) — authoritative

// ✅ Global cap (LOCKED)
const MAX_SHELVES_TOTAL = 8;

// ---------- helpers ----------
const isoNow = () => new Date().toISOString();
const round2 = (x) => Math.round(Number(x) * 100) / 100;

function clampInt(x, lo, hi) {
  const n = Math.round(Number(x));
  if (!Number.isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, n));
}

// Normalize Polygon aggregate bars to { time(sec), open, high, low, close, volume }
function normalizeBars(raw) {
  if (!Array.isArray(raw)) return [];
  return raw
    .map((b) => {
      const tms = Number(b.t ?? b.time ?? 0);
      const t = tms > 1e12 ? Math.floor(tms / 1000) : tms;
      return {
        time: t,
        open: Number(b.o ?? b.open ?? 0),
        high: Number(b.h ?? b.high ?? 0),
        low: Number(b.l ?? b.low ?? 0),
        close: Number(b.c ?? b.close ?? 0),
        volume: Number(b.v ?? b.volume ?? 0),
      };
    })
    .filter(
      (b) =>
        Number.isFinite(b.time) &&
        Number.isFinite(b.open) &&
        Number.isFinite(b.high) &&
        Number.isFinite(b.low) &&
        Number.isFinite(b.close)
    )
    .sort((a, b) => a.time - b.time);
}

function spanInfo(label, bars) {
  if (!Array.isArray(bars) || bars.length === 0) {
    console.log(`[SHELVES] COVERAGE ${label}: none`);
    return { first: null, last: null, spanDays: null };
  }

  const first = bars[0].time;
  const last = bars[bars.length - 1].time;
  const days = (last - first) / 86400;

  console.log(
    `[SHELVES] COVERAGE ${label}:`,
    "bars =", bars.length,
    "| from =", new Date(first * 1000).toISOString(),
    "| to =", new Date(last * 1000).toISOString(),
    "| spanDays =", days.toFixed(1)
  );

  return { first, last, spanDays: days };
}

function lastClose(bars) {
  if (!Array.isArray(bars) || !bars.length) return null;
  const c = bars[bars.length - 1]?.close;
  return Number.isFinite(c) ? c : null;
}

function pickCurrentPriceAnchor({ bars30m, bars1h }) {
  const c30 = lastClose(bars30m);
  const c1h = lastClose(bars1h);

  if (Number.isFinite(c30) && Number.isFinite(c1h)) {
    const diff = Math.abs(c30 - c1h);
    if (diff > 5) {
      console.warn("[SHELVES] WARNING: 30m vs 1h close mismatch:", { c30, c1h, diff });
    }
    return c30;
  }

  return Number.isFinite(c30) ? c30 : (Number.isFinite(c1h) ? c1h : null);
}

function normalizeType(t) {
  const x = String(t ?? "").toLowerCase();
  if (x === "accumulation" || x === "acc") return "accumulation";
  if (x === "distribution" || x === "dist") return "distribution";
  return null;
}

function normalizeRange(pr) {
  if (!Array.isArray(pr) || pr.length !== 2) return null;
  const a = Number(pr[0]);
  const b = Number(pr[1]);
  if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
  const hi = round2(Math.max(a, b));
  const lo = round2(Math.min(a, b));
  if (!(hi > lo)) return null;
  const width = hi - lo;
  const mid = (hi + lo) / 2;
  return { hi, lo, width, mid };
}

function overlapsBand(hi, lo, bandLow, bandHigh) {
  return hi >= bandLow && lo <= bandHigh;
}

// strict any overlap / touch
function rangesOverlap(aHi, aLo, bHi, bLo) {
  return !(aHi < bLo || aLo > bHi);
}
// overlap ratio (used for 25% institutional overlap rule)
function overlapRatio(aHi, aLo, bHi, bLo) {
  const lo = Math.max(aLo, bLo);
  const hi = Math.min(aHi, bHi);
  const inter = hi - lo;
  if (inter <= 0) return 0;
  const denom = Math.min(aHi - aLo, bHi - bLo);
  return denom > 0 ? inter / denom : 0;
}

function rangeGapPts(aHi, aLo, bHi, bLo) {
  if (rangesOverlap(aHi, aLo, bHi, bLo)) return 0;
  if (aHi < bLo) return bLo - aHi;
  if (bHi < aLo) return aLo - bHi;
  return 0;
}

function filterShelvesToBand(levels, currentPrice, bandPoints) {
  if (!Array.isArray(levels)) return [];
  if (!Number.isFinite(currentPrice)) return levels;

  const lo = currentPrice - bandPoints;
  const hi = currentPrice + bandPoints;

  return levels.filter((s) => {
    const r = normalizeRange(s?.priceRange);
    if (!r) return false;
    return overlapsBand(r.hi, r.lo, lo, hi);
  });
}

function remapShelvesStrengthToBand(levels, lo = SHELF_STRENGTH_LO, hi = SHELF_STRENGTH_HI) {
  if (!Array.isArray(levels) || levels.length === 0) {
    return { levels, minRaw: null, maxRaw: null };
  }

  const rawVals = levels
    .map((x) => Number(x?.strength))
    .filter((n) => Number.isFinite(n));

  if (rawVals.length === 0) {
    return { levels, minRaw: null, maxRaw: null };
  }

  const minRaw = Math.min(...rawVals);
  const maxRaw = Math.max(...rawVals);

  if (maxRaw === minRaw) {
    const mapped = levels.map((x) => ({
      ...x,
      strength_raw: Number(x?.strength ?? 0),
      strength: hi,
    }));
    return { levels: mapped, minRaw, maxRaw };
  }

  const mapped = levels.map((x) => {
    const raw = Number(x?.strength ?? 0);
    const t = (raw - minRaw) / (maxRaw - minRaw);
    const scaled = lo + (hi - lo) * t;
    const strength = clampInt(scaled, lo, hi);
    return { ...x, strength_raw: raw, strength };
  });

  return { levels: mapped, minRaw, maxRaw };
}

// ---------------- Institutional structures (structures_sticky) ----------------

function loadStickyStructureRanges() {
  if (!fs.existsSync(LEVELS_FILE)) {
    console.warn(`[SHELVES] levels file not found for structure filter (ok): ${LEVELS_FILE}`);
    return [];
  }

  try {
    const raw = fs.readFileSync(LEVELS_FILE, "utf8");
    const json = JSON.parse(raw);
    const arr = Array.isArray(json?.structures_sticky) ? json.structures_sticky : [];

    const ranges = arr
      .map((z) => {
        const pr = z?.priceRange;
        const r = normalizeRange(pr);
        return r ? { hi: r.hi, lo: r.lo } : null;
      })
      .filter(Boolean);

    console.log(`[SHELVES] Loaded sticky structures for overlap filter: ${ranges.length} (${path.basename(LEVELS_FILE)})`);
    return ranges;
  } catch (e) {
    console.warn(`[SHELVES] Failed to read sticky structures from ${LEVELS_FILE}: ${e?.message}`);
    return [];
  }
}

function removeShelvesOverlappingStickyStructures(levels, stickyRanges) {
  const list = Array.isArray(levels) ? levels : [];
  const structs = Array.isArray(stickyRanges) ? stickyRanges : [];
  if (!list.length || !structs.length) return { kept: list, removedCount: 0 };

  let removed = 0;

  const kept = list.filter((s) => {
    const r = normalizeRange(s?.priceRange);
    if (!r) return false;

  const overlapsAny = structs.some(
   (z) => overlapRatio(r.hi, r.lo, z.hi, z.lo) >= 0.25
 );

    if (overlapsAny) removed++;
    return !overlapsAny;
  });

  if (removed) {
    console.log(`[SHELVES] Removed shelves overlapping sticky structures (strict): ${removed}`);
  }
  return { kept, removedCount: removed };
}

// ---------------- Manual shelves (source of truth) ----------------

function loadManualShelves() {
  if (!fs.existsSync(MANUAL_FILE)) {
    console.log(`[SHELVES] Manual shelves file not found (ok): ${MANUAL_FILE}`);
    return [];
  }
  try {
    const raw = fs.readFileSync(MANUAL_FILE, "utf8");
    const json = JSON.parse(raw);
    const arr = Array.isArray(json?.levels) ? json.levels : [];

    const out = arr
      .map((s) => {
        const type = normalizeType(s?.type);
        if (!type) return null;

        const r = normalizeRange(
          Array.isArray(s?.manualRange) && s.manualRange.length === 2
            ? s.manualRange
            : s.priceRange
        );
        if (!r) return null;

        const scoreOverride = Number.isFinite(Number(s?.scoreOverride))
          ? Number(s.scoreOverride)
          : null;

        const strengthBase = scoreOverride ?? Number(s?.strength ?? 75);
        const strength = clampInt(strengthBase, SHELF_STRENGTH_LO, SHELF_STRENGTH_HI);

        return {
          type,
          price: round2(r.mid),
          priceRange: [r.hi, r.lo],
          strength,
          strength_source: scoreOverride != null ? "manual_override" : "manual_default",
          scoreOverride,
          comment: typeof s?.comment === "string" ? s.comment : null,
          locked: true,
          rangeSource: "manual",
          shelfKey: s?.shelfKey ?? null,
          status: s?.status ?? "active",
        };
      })
      .filter(Boolean)
      .filter((s) => String(s.status).toLowerCase() !== "inactive");

    console.log(`[SHELVES] Manual shelves loaded: ${out.length} (${MANUAL_FILE})`);
    return out;
  } catch (e) {
    console.warn(`[SHELVES] Manual shelves failed to load: ${MANUAL_FILE} :: ${e?.message}`);
    return [];
  }
}

function isManualShelf(s) {
  return s?.rangeSource === "manual" || s?.locked === true || Number.isFinite(Number(s?.scoreOverride));
}

// ✅ TYPE-AWARE removal: manual removes autos only if same type overlaps
function removeAutosOverlappingManualSameType(autoLevels, manualLevels) {
  if (!Array.isArray(autoLevels) || autoLevels.length === 0) return [];
  if (!Array.isArray(manualLevels) || manualLevels.length === 0) return autoLevels;

  let removed = 0;

  const out = autoLevels.filter((a) => {
    const at = normalizeType(a?.type);
    if (!at) return false;

    const ar = normalizeRange(a?.priceRange);
    if (!ar) return false;

    const overlapsSameTypeManual = manualLevels.some((m) => {
      const mt = normalizeType(m?.type);
      if (!mt || mt !== at) return false;

      const mr = normalizeRange(m?.priceRange);
      if (!mr) return false;

      return rangesOverlap(ar.hi, ar.lo, mr.hi, mr.lo);
    });

    if (overlapsSameTypeManual) removed++;
    return !overlapsSameTypeManual;
  });

  if (removed) console.log(`[SHELVES] Autos removed due to MANUAL overlap (same type only): ${removed}`);
  return out;
}

function shelfOverlapRatio(a, b) {
  const ar = normalizeRange(a?.priceRange);
  const br = normalizeRange(b?.priceRange);
  if (!ar || !br) return 0;
  const interLo = Math.max(ar.lo, br.lo);
  const interHi = Math.min(ar.hi, br.hi);
  const inter = interHi - interLo;
  if (inter <= 0) return 0;
  const denom = Math.min(ar.width, br.width);
  return denom > 0 ? inter / denom : 0;
}

function shelfBelongsToCluster(s, rep) {
  const sr = normalizeRange(s?.priceRange);
  const rr = normalizeRange(rep?.priceRange);
  if (!sr || !rr) return false;

  const ov = shelfOverlapRatio(s, rep);
  if (ov >= SHELF_CLUSTER_OVERLAP) return true;

  const gap = rangeGapPts(sr.hi, sr.lo, rr.hi, rr.lo);
  if (gap <= SHELF_CLUSTER_GAP_PTS) return true;

  return false;
}

function pickBestOfType(items, type) {
  const list = (items || [])
    .filter((x) => normalizeType(x?.type) === type)
    .slice()
    .sort((a, b) => {
      const ma = isManualShelf(a) ? 1 : 0;
      const mb = isManualShelf(b) ? 1 : 0;
      if (mb !== ma) return mb - ma;
      const sb = Number(b?.strength ?? 0) - Number(a?.strength ?? 0);
      if (sb !== 0) return sb;
      const aw = normalizeRange(a?.priceRange)?.width ?? Infinity;
      const bw = normalizeRange(b?.priceRange)?.width ?? Infinity;
      return aw - bw;
    });

  return list[0] ?? null;
}

function collapseShelvesByCluster(levels) {
  const list = Array.isArray(levels) ? levels.slice() : [];
  if (!list.length) return [];

  list.sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));

  const clusters = [];

  for (const s of list) {
    const sr = normalizeRange(s?.priceRange);
    const st = normalizeType(s?.type);
    if (!sr || !st) continue;

    let placed = false;

    for (const c of clusters) {
      if (shelfBelongsToCluster(s, c.rep)) {
        c.members.push(s);

        const rep = c.rep;
        const repManual = isManualShelf(rep) ? 1 : 0;
        const sManual = isManualShelf(s) ? 1 : 0;

        if (sManual > repManual) c.rep = s;
        else if (sManual === repManual) {
          const ss = Number(s?.strength ?? 0);
          const rs = Number(rep?.strength ?? 0);
          if (ss > rs) c.rep = s;
          else if (ss === rs) {
            const sw = sr.width;
            const rw = normalizeRange(rep?.priceRange)?.width ?? Infinity;
            if (sw < rw) c.rep = s;
          }
        }

        placed = true;
        break;
      }
    }

    if (!placed) clusters.push({ rep: s, members: [s] });
  }

  const out = [];

  for (const c of clusters) {
    const bestAcc = pickBestOfType(c.members, "accumulation");
    const bestDist = pickBestOfType(c.members, "distribution");
    if (bestAcc) out.push(bestAcc);
    if (bestDist) out.push(bestDist);
  }

  out.sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));
  return out;
}

function applyGlobalCap(levels, maxTotal = MAX_SHELVES_TOTAL) {
  const list = Array.isArray(levels) ? levels.slice() : [];
  if (list.length <= maxTotal) return list;

  const targetEach = Math.floor(maxTotal / 2);

  const acc = list
    .filter((x) => normalizeType(x?.type) === "accumulation")
    .sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));

  const dist = list
    .filter((x) => normalizeType(x?.type) === "distribution")
    .sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));

  const picked = [];
  picked.push(...acc.slice(0, targetEach));
  picked.push(...dist.slice(0, targetEach));

  if (picked.length < maxTotal) {
    const pickedSet = new Set(picked.map((x) => x));
    const leftovers = list
      .filter((x) => !pickedSet.has(x))
      .sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));
    picked.push(...leftovers.slice(0, maxTotal - picked.length));
  }

  picked.sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));
  return picked.slice(0, maxTotal);
}

// ✅ NEW: Final "no-touch winner" pass.
// Sort by strength desc; keep only shelves that do NOT overlap/touch any kept shelf.
function applyNoTouchWinnerPass(levels) {
  const list = Array.isArray(levels) ? levels.slice() : [];
  if (!list.length) return [];

  list.sort((a, b) => Number(b?.strength ?? 0) - Number(a?.strength ?? 0));

  const kept = [];
  let removed = 0;

  for (const s of list) {
    const sr = normalizeRange(s?.priceRange);
    if (!sr) continue;

    const touchesExisting = kept.some((k) => {
      const kr = normalizeRange(k?.priceRange);
      if (!kr) return false;
      return rangesOverlap(sr.hi, sr.lo, kr.hi, kr.lo); // strict any overlap/touch
    });

    if (touchesExisting) {
      removed++;
      continue;
    }

    kept.push(s);
  }

  if (removed) {
    console.log(`[SHELVES] No-touch winner pass removed: ${removed}`);
  }

  return kept;
}

// ---------------- main ----------------

async function main() {
  try {
    console.log("[SHELVES] Fetching bars (DEEP)…");

    const [bars15mRaw, bars30mRaw, bars1hRaw] = await Promise.all([
      getBarsFromPolygonDeep(SYMBOL, "15m", DAYS_15M),
      getBarsFromPolygonDeep(SYMBOL, "30m", DAYS_30M),
      getBarsFromPolygonDeep(SYMBOL, "1h", DAYS_1H),
    ]);

    const bars15m = normalizeBars(bars15mRaw);
    const bars30m = normalizeBars(bars30mRaw);
    const bars1h = normalizeBars(bars1hRaw);

    console.log("[SHELVES] 15m bars:", bars15m.length);
    console.log("[SHELVES] 30m bars:", bars30m.length);
    console.log("[SHELVES] 1h  bars:", bars1h.length);

    const s15 = spanInfo("15m", bars15m);
    const s30 = spanInfo("30m", bars30m);
    const s1h = spanInfo("1h", bars1h);

    const currentPriceAnchor = pickCurrentPriceAnchor({ bars30m, bars1h });
    if (!Number.isFinite(currentPriceAnchor)) {
      throw new Error("Cannot determine currentPriceAnchor from 30m/1h bars");
    }

    console.log("[SHELVES] currentPriceAnchor (from 30m/1h):", currentPriceAnchor.toFixed(2));

    // ✅ Institutional sticky structure ranges (authoritative)
    const stickyStructureRanges = loadStickyStructureRanges();

    // 1) Manual shelves (source-of-truth)
    const manualAll = loadManualShelves();
    const manualInBand = filterShelvesToBand(manualAll, currentPriceAnchor, BAND_POINTS);

    // 2) Auto shelves (scanner)
    console.log("[SHELVES] Running shelves scanner (Acc/Dist)…");
    const shelvesRaw =
      computeShelves({
        bars10m: bars15m, // historical naming
        bars30m,
        bars1h,
        bandPoints: BAND_POINTS,
      }) || [];

    const shelvesBand = filterShelvesToBand(shelvesRaw, currentPriceAnchor, BAND_POINTS);

    console.log("[SHELVES] Shelves generated (auto raw):", shelvesRaw.length);
    console.log("[SHELVES] Shelves kept (auto band):", shelvesBand.length);
    console.log("[SHELVES] Shelves kept (manual band):", manualInBand.length);

    // 3) Manual wins overlap (TYPE-AWARE): remove overlapping autos only if same type
    const autoNoOverlap = removeAutosOverlappingManualSameType(shelvesBand, manualInBand);

    // 4) Remap AUTO strengths into shelf band (60–89)
    const { levels: autoMapped, minRaw, maxRaw } = remapShelvesStrengthToBand(
      autoNoOverlap,
      SHELF_STRENGTH_LO,
      SHELF_STRENGTH_HI
    );

    // 5) Merge shelves
    const mergedRaw = [...manualInBand, ...autoMapped];

    // ✅ TEMP CLEAN RULE: remove ANY shelf overlapping ANY sticky structure (strict)
    const { kept: mergedNoInstitution, removedCount: removedByInstitution } =
      removeShelvesOverlappingStickyStructures(mergedRaw, stickyStructureRanges);

    // 6) Cluster-collapse (max 1 acc + 1 dist per cluster)
    const collapsed = collapseShelvesByCluster(mergedNoInstitution);

    // 7) Global cap (max 8 total)
    const capped = applyGlobalCap(collapsed, MAX_SHELVES_TOTAL);

    // ✅ 8) Final "no-touch winner" pass (no shelves can touch)
    const finalLevels = applyNoTouchWinnerPass(capped);

    console.log("[SHELVES] Strength remap:", {
      band: `${SHELF_STRENGTH_LO}-${SHELF_STRENGTH_HI}`,
      minRaw,
      maxRaw,
    });

    console.log(
      `[SHELVES] Emitting shelves: manual ${manualInBand.length} + auto ${autoMapped.length} => merged ${mergedRaw.length} => afterInstitutionFilter ${mergedNoInstitution.length} (removed ${removedByInstitution}) => collapsed ${collapsed.length} => capped ${capped.length} => final ${finalLevels.length}`
    );

    const payload = {
      ok: true,
      meta: {
        generated_at_utc: isoNow(),
        symbol: SYMBOL,
        band_points: BAND_POINTS,
        current_price_anchor: Number(currentPriceAnchor.toFixed(2)),
        lookback_days: { "15m": DAYS_15M, "30m": DAYS_30M, "1h": DAYS_1H },
        coverage: { "15m": s15, "30m": s30, "1h": s1h },
        strength_band: {
          lo: SHELF_STRENGTH_LO,
          hi: SHELF_STRENGTH_HI,
          min_raw: Number.isFinite(minRaw) ? Number(minRaw) : null,
          max_raw: Number.isFinite(maxRaw) ? Number(maxRaw) : null,
        },
        manual_file: path.basename(MANUAL_FILE),
        manual_loaded_in_band: manualInBand.length,
        cluster_rules: {
          overlap_ratio: SHELF_CLUSTER_OVERLAP,
          gap_pts: SHELF_CLUSTER_GAP_PTS,
          max_per_cluster: "1 accumulation + 1 distribution",
          global_cap_total: MAX_SHELVES_TOTAL,
          manual_override: "manual wins within its type; opposite type still allowed in same cluster",
        },
        institutional_filter: {
          enabled: true,
          source: path.basename(LEVELS_FILE),
          key: "structures_sticky",
          rule: "overlap_ratio>=0.25",
          structures_count: stickyStructureRanges.length,
          shelves_removed: removedByInstitution,
        },
        no_touch_winner: {
          enabled: true,
          rule: "strict_any_overlap",
          winner: "higher_strength_kept",
        },
      },
      levels: finalLevels,
    };

    fs.mkdirSync(path.dirname(OUTFILE), { recursive: true });
    fs.writeFileSync(OUTFILE, JSON.stringify(payload, null, 2), "utf8");

    console.log("[SHELVES] Saved shelves to:", OUTFILE);
    console.log("[SHELVES] Job complete.");
  } catch (err) {
    console.error("[SHELVES] FAILED:", err);

    try {
      const fallback = {
        ok: true,
        levels: [],
        note: "SMZ shelves job error, no shelves generated this run",
      };
      fs.mkdirSync(path.dirname(OUTFILE), { recursive: true });
      fs.writeFileSync(OUTFILE, JSON.stringify(fallback, null, 2), "utf8");
      console.log("[SHELVES] Wrote fallback empty smz-shelves.json");
    } catch (inner) {
      console.error("[SHELVES] Also failed to write fallback smz-shelves.json:", inner);
    }

    process.exitCode = 1;
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export default main;
